function [vFinal, mFinal, burnTime, errorV] = orbitalVelocity(oH,mI)
%[V,MFINAL,BURNTIME,ERRORV] = orbitalInsertion(OH,TC) computes the IVP solution using orbit
%height OH in m. Outputs VFINAL as final projectile velocity, MFINAL as
%final mass of projectile, BURNTIME as the time projectile thrusters are on
%and ERRORV as the error between orbital velocity and final projectile
%velocity.Function assumes entering a stable circular orbit.

% Use initial mass of 25000 as mentioned in assignment briefing. Update mI
% after first run through of code. If manoeuvre not possible, code will
% break and display message.

% Upper stage parameters
mE = 200; % Mass out rate per second
mD = 0.5e3; % Dry mass
mF = 20e3; % Fuel mass
Vf = 1.3144e3; % Initial velocity
exhaustDiam = 1.5; % Nozzle exhaust diameter
exhaustVel = 3000; % Exhaust velocity
exPressure = 150e3; % Exit pressure

% Important generic values
G = 6.674e-11; % Gravitational constant
Me = 5.972e24; % Mass of earth
Re = 6378e3; % Radius in m
orbitHeight = Re + oH; 
orbitPeriod = sqrt((4*pi^2*orbitHeight^3)/(G*Me)); % Orbital period
a = (G*Me)/(orbitHeight^2); % Acceleration of gravity at input height, oH

% Mass change vector
massChange = [mI:-mE:3500];

% Thrust generated by nozzle
nozThrust = mE*exhaustVel+(exPressure-0)*(pi*exhaustDiam^2)/4;
forceConst = nozThrust(ones(1,length(massChange)));

% Acceleration due to mass change
accelProj = forceConst./massChange;

timeStep = 1; 
ts = timeStep(ones(1,length(massChange)));

% Orbital velocity
Vc = sqrt((G*Me)/((Re+oH)));

% Delta V required to reach orbital velocity
deltaV = Vc - Vf;

n = 1;
iterCount = 0;
while Vc > Vf
   
    if n > length(massChange)
        disp('Maneouvre not possible with remaining resources. Recalculations of desired orbit height required.')
    end

    % iterCount counts each iteration of while loop. Each iteration is a second of burn
    % time.
    iterCount = iterCount + 1;

    % Change in velocity accounting for changing accelerations
    Vf = Vf + accelProj(n)*ts(n);

    n = n+1;
end

% If while loop produces overshoot. If statement used to correct.
if Vf > Vc
    Vf = Vf - accelProj(n-1)*ts(n-1);
end 

% Difference produced by IF statement corrected in following section.
% Assumed constant acceleration for timeDelta due to small value (timeDelta
% < 1).
vDiff = Vc - Vf;
timeDelta = vDiff/accelProj(n-1);

vFinal = Vf + accelProj(n)*timeDelta;
mFinal = mI - (mE*iterCount) - mE*timeDelta;
burnTime = iterCount + timeDelta;
errorV = 100*((vFinal - Vc)/Vc); % Error is small. Creates discrepancy of orbital height of around +/- 0.03%


dataRead = orbitPeriod/round(burnTime)+1; % Completes circle
motion = -dataRead; % Makes velocity and radius graph cross x = 0. 
for i = 1:1:round(burnTime)

    motion = motion+dataRead; % Ensures that orbit motion starts at t = 0.
    t(i) = motion; 
    orbVelocity(i) = vFinal; 
    rt(i) = orbitHeight; % Creates an array of radii values along with corresponding time values.

end

% Ensure that orbital velocity is constant and stays constant. Graph should be
%straight line
figure
plot(t,orbVelocity);
xlabel('Elapsed time (s)')
ylabel('Velocity (m/s)')

% Ensure that orbital height constant. Graph should be straight line
figure
plot(t,rt);
xlabel('Elapsed time (s)')
ylabel('Orbit Radius (m)')

% Multiple by t to scale 
theta = 2*pi*t/orbitPeriod;
magLine = sqrt((t.^2)+(rt.^2));

figure
polarplot(theta,magLine)
title('Circular orbit trajectory of projectile')

